import numpy as npimport numpy.matlib as nmimport numpy.linalg as nlimport qunex as qxdef swapping(C,D):        def transpose(A):        rowA,colA=A.shape        AT=nm.asmatrix([[A[i,j]for i in range(rowA)]for j in range(colA)])        return(AT)    def dagger(A):        B=nm.asmatrix(np.conj(transpose(A)))        return(B)    def orthogonalization(A):        q,r=nl.qr(A)        d=nm.asmatrix([[0+0j for i in range(len(r))]for j in range(len(r))])        for i in range(len(A)):            d[i,i]=r[i,i]/abs(r[i,i])        return(nm.asmatrix(np.dot(q,d)))    rho1234=np.kron(C,D)    bsm1=nm.asmatrix([[0.5,0,0,0.5],                      [0,0,0,0],                      [0,0,0,0],                      [0.5,0,0,0.5]]);                  # Matrix corresponding to Bell state phi plus    bsm2=nm.asmatrix([[0.5,0,0,-0.5],                      [0,0,0,0],                      [0,0,0,0],                      [-0.5,0,0,0.5]]);                # Matrix corresponding to Bell state phi minus    bsm3=nm.asmatrix([[0,0,0,0],                      [0,0.5,0.5,0],                      [0,0.5,0.5,0],                      [0,0,0,0]]);                 # Matrix corresponding to Bell state psi plus     bsm4=nm.asmatrix([[0,0,0,0],                      [0,0.5,-0.5,0],                      [0,-0.5,0.5,0],                      [0,0,0,0]]);                # Matrix corresponding to Bell state psi minus    Idn=nm.asmatrix([[1,0],                     [0,1]]);                     # Identity matrix        def rho14beta(A,B):    # Inputs are 4qubit density matrix and measurement matrix and output is 2qubit density matrix after entanglement swapping        preresult=nm.asmatrix(np.dot(A,B))        MeasuredMatrix=nm.asmatrix(np.dot(B,preresult))        MM1=MeasuredMatrix        TraceMM1=MeasuredMatrix.trace()[0,0]        rho14=nm.asmatrix([[MM1[0,0]+MM1[2,2]+MM1[4,4]+MM1[6,6],MM1[0,1]+MM1[2,3]+MM1[4,5]+MM1[6,7],MM1[0,8]+MM1[2,10]+MM1[4,12]+MM1[6,14],MM1[0,9]+MM1[2,11]+MM1[4,13]+MM1[6,15]],                      [MM1[1,0]+MM1[3,2]+MM1[5,4]+MM1[7,6],MM1[1,1]+MM1[3,3]+MM1[5,5]+MM1[7,7],MM1[1,8]+MM1[3,10]+MM1[5,12]+MM1[7,14],MM1[1,9]+MM1[3,11]+MM1[5,13]+MM1[7,15]],                      [MM1[8,0]+MM1[10,2]+MM1[12,4]+MM1[14,6],MM1[8,1]+MM1[10,3]+MM1[12,5]+MM1[14,7],MM1[8,8]+MM1[10,10]+MM1[12,12]+MM1[14,14],MM1[8,9]+MM1[10,11]+MM1[12,13]+MM1[14,15]],                      [MM1[9,0]+MM1[11,2]+MM1[13,4]+MM1[15,6],MM1[9,1]+MM1[11,3]+MM1[13,5]+MM1[15,7],MM1[9,8]+MM1[11,10]+MM1[13,12]+MM1[15,14],MM1[9,9]+MM1[11,11]+MM1[13,13]+MM1[15,15]]])/TraceMM1;        return(rho14)    MeasurementMatrix1=np.kron(Idn,(np.kron(bsm1,Idn)))    rho14phiplus=rho14beta(rho1234,MeasurementMatrix1)    #print('rho14phiplus=',rho14phiplus)    probphiplus=(nm.asmatrix(np.dot(dagger(MeasurementMatrix1),np.dot(MeasurementMatrix1,rho1234)))).trace()[0,0]    c14phiplus=qx.concurrence(rho14phiplus)    #print('probability of rho14phiplus=',probphiplus)    #print('c14phiplus=',c14phiplus)    MeasurementMatrix2=np.kron(Idn,(np.kron(bsm2,Idn)))         rho14phiminus=rho14beta(rho1234,MeasurementMatrix2)    #print('rho14phiminus=',rho14phiminus)    probphiminus=(nm.asmatrix(np.dot(dagger(MeasurementMatrix2),np.dot(MeasurementMatrix2,rho1234)))).trace()[0,0]    c14phiminus=qx.concurrence(rho14phiminus)    #print('probability of rho14phiminus=',probphiminus)    #print('c14phiminus=',c14phiminus)    MeasurementMatrix3=np.kron(Idn,(np.kron(bsm3,Idn)))        rho14psiplus=rho14beta(rho1234,MeasurementMatrix3)    #print('rho14psiplus=',rho14psiplus)    probpsiplus=(nm.asmatrix(np.dot(dagger(MeasurementMatrix3),np.dot(MeasurementMatrix3,rho1234)))).trace()[0,0]    c14psiplus=qx.concurrence(rho14psiplus)    #print('probability of rho14psiplus=',probpsiplus)    #print('c14psiplus=',c14psiplus)    MeasurementMatrix4=np.kron(Idn,(np.kron(bsm4,Idn)))         rho14psiminus=rho14beta(rho1234,MeasurementMatrix4)    #print('rho14psiminus=',rho14psiminus)    probpsiminus=(nm.asmatrix(np.dot(dagger(MeasurementMatrix4),np.dot(MeasurementMatrix4,rho1234)))).trace()[0,0]    c14psiminus=qx.concurrence(rho14psiminus)    #print('probability of rho14psiminus=',probpsiminus)    #print('c14psiminus=',c14psiminus)        avgC=(probphiplus*c14phiplus+probphiminus*c14phiminus+probpsiplus*c14psiplus+probpsiminus*c14psiminus)    #print('Average Concurrence=',avgC)    return(abs(avgC))