import networkx as nximport randomimport numpy as npimport qunex as qxclass FindViableRegion:    def __init__(        self,        graph,        parameter_name,        parameter_swapping_rule=None,        parameter_threshold=0,        min_req_prob=None,        num_samples=100,        seed=None    ):        self.graph = graph        self.param_name = parameter_name        self.threshold = parameter_threshold        self.required_prob = min_req_prob        if parameter_swapping_rule is None:            if parameter_name == "concurrence":                self.rule = qx.swapped_concurrence_werner            elif parameter_name == "fidelity":                self.rule = qx.swapped_fidelity_werner            elif parameter_name == "probability":                self.rule = qx.swapped_probability            else:                raise ValueError(                    f"parameter_swapping_rule must be provided for parameter '{parameter_name}'"                )        else:            self.rule = parameter_swapping_rule        if seed is not None:            random.seed(seed)        self.num_samples = min(num_samples, graph.number_of_nodes())        self.nodes = list(graph.nodes())        self.sources = random.sample(self.nodes, self.num_samples)        self._avg_viable_radius = None        self._avg_viable_node_frac = None    def simulate(self):        viable_radii = []        viable_node_fracs = []        N = self.graph.number_of_nodes()        for source in self.sources:            viable_distances = []            viable_count = 0            spl = nx.single_source_shortest_path_length(self.graph, source)            paths = nx.single_source_shortest_path(self.graph, source)            for dest, dist in spl.items():                if dest == source:                    continue                path = paths[dest]                finder = qx.FindPathParameters(self.graph, path)                path_param = finder.compute(                    parameter_name=self.param_name,                    rule=self.rule                )                if path_param >= self.threshold:                    viable_count += 1                    viable_distances.append(dist)            radius_s = max(viable_distances) if viable_distances else 0            frac_s = viable_count / (N - 1)            viable_radii.append(radius_s)            viable_node_fracs.append(frac_s)        self._avg_viable_radius = float(np.mean(viable_radii))        self._avg_viable_node_frac = float(np.mean(viable_node_fracs))    def viable_radius(self):        if self._avg_viable_radius is None:            self.simulate()        return self._avg_viable_radius    def viable_node_fraction(self):        if self._avg_viable_node_frac is None:            self.simulate()        return self._avg_viable_node_frac